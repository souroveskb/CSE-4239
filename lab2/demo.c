/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "matrixOperator.h"


void printMatrix(int nrows, int ncols, float* data){

	int currentIndex = 0;
	for(int i = 0; i < nrows; i++){
		for(int j = 0; j < ncols; j++){
			printf("%f ",data[currentIndex++]);
		}
		printf("\n");
	}
}


void matrix_operations_1(char *host, Input input, int id)
{
	CLIENT *clnt;
	Output  *result;
	// Input  add_1_arg;
	// Output  *result_2;
	// Input  multiply_1_arg;
	// Output  *result_3;
	// Input  inverse_1_arg;
	// Output  *result_4;
	// Input  transpose_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, MATRIX_OPERATIONS, MATRIX_VERSION, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	if(id == 1){
		result = add_1(&input, clnt);
		if (result == NULL) {
			clnt_perror(clnt, "call failed:");
		}
		if(result->errorCode != 0){
			printf("Error: %s\n",result->errorMessage);
		}else{
			printf("Result:\n");
			printMatrix(result->result.nRows,result->result.nColumns,result->result.data);
		}

	}else if(id == 2){
		result = multiply_1(&input, clnt);
		if (result == NULL) {
			clnt_perror(clnt, "call failed:");
		}
		if(result->errorCode != 0){
			printf("Error: %s\n",result->errorMessage);
		}else{
			printf("Result:\n");
			printMatrix(result->result.nRows,result->result.nColumns,result->result.data);
		}		
	}else if(id == 3){

		result = inverse_1(&input, clnt);
		if (result == NULL) {
			clnt_perror(clnt, "call failed:");
		}
		if(result->errorCode != 0){
			printf("Error: %s\n",result->errorMessage);
		}else{
			printf("Result:\n");
			printMatrix(result->result.nRows,result->result.nColumns,result->result.data);
		}
	}else{
		result = transpose_1(&input, clnt);
		if (result == NULL) {
			clnt_perror(clnt, "call failed:");
		}
		if(result->errorCode != 0){
			printf("Error: %s\n",result->errorMessage);
		}else{
			printf("Result:\n");
			printMatrix(result->result.nRows,result->result.nColumns,result->result.data);
		}
	}

#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


void getUserInputMatrix(int numberOfRows, int numberOfCols, float* data){
	int currentIndex = 0;
	printf("Enter values for Matrix:\n");
    for (int i = 0; i < numberOfRows; i++) {
        for (int j = 0; j < numberOfCols; j++) {
            scanf("%f", &data[currentIndex++]);
        }
    }
}

int main (int argc, char *argv[])
{
	char *host;

	if (argc < 2) {
		host = "localhost";
		// printf ("usage: %s server_host\n", argv[0]);
		// exit (1);
	} else{
		host = argv[1];

	}


	Input input;
	int op_id, nrows, ncols;

	printf("Choose an Operation:\n");
	printf("1.Addition\n2.Multiplication\n3.Inverse\n4.Transpose\nSelect: ");
	scanf("%d", &op_id);

	if(op_id == 1 || op_id == 2){

		input.numOfMatrices = 2;

    	printf("Enter the number of rows: ");
    	scanf("%d", &nrows);
    	printf("Enter the number of columns: ");
    	scanf("%d", &ncols);

    	getUserInputMatrix(nrows,ncols,input.matrices[0].data);
		input.matrices[0].nRows = nrows;
		input.matrices[0].nColumns = ncols;

		getUserInputMatrix(nrows,ncols,input.matrices[1].data);
		input.matrices[1].nRows = nrows;
		input.matrices[1].nColumns = ncols;


	}else if(op_id == 3){

		input.numOfMatrices = 1;

		printf("Enter the order of the matrix: ");
    	scanf("%d", &nrows);

		ncols = nrows;

    	getUserInputMatrix(nrows,ncols,input.matrices[0].data);
		input.matrices[0].nRows = nrows;
		input.matrices[0].nColumns = ncols;

	}else if(op_id == 4){

		input.numOfMatrices = 1;

		printf("Enter the number of rows: ");
    	scanf("%d", &nrows);
    	printf("Enter the number of columns: ");
    	scanf("%d", &ncols);

    	getUserInputMatrix(nrows,ncols,input.matrices[0].data);
		input.matrices[0].nRows = nrows;
		input.matrices[0].nColumns = ncols;

	}else{
		printf("Invalid input\n");
		return -1;
	}

	printf("%d", op_id);

	matrix_operations_1 (host,input,op_id);
exit (0);
}



///CLIENT

/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "matrixOperator.h"


void inputMatrix(Matrix* M)
{
    printf("Enter number of Rows( <= 10) : ");
    scanf("%d", &(M->nRows));

    printf("Enter number of Columns( <= 10) : ");
    scanf("%d", &(M->nColumns));

    printf("Enter Matrix :\n");

    for(int i = 0, k = 0; i < M->nRows; i++) {
        for(int j = 0; j < M->nColumns; j++, k++) {
            scanf("%lf", &(M->data[k]));
        }
    }
}


void
matrix_prog_1(char *host, int op)
{
	CLIENT *clnt;
	Matrix  *result_1;
	Massage  addtwomatrix_1_arg;
	Matrix  *result_2;
	Massage  multiplytwomatrix_1_arg;
	Matrix  *result_3;
	Massage  inversematrix_1_arg;
	Matrix  *result_4;
	Massage  transposematrix_1_arg;

#ifndef	DEBUG
    clnt = clnt_create (host, MATRIX_PROG, ADD_VERS, "udp");
    if (clnt == NULL) {
        clnt_pcreateerror (host);
        exit (1);
    }
#endif	/* DEBUG */

    if(op == 1) {
        printf("Enter First Matrix.\n");
        inputMatrix(&(addtwomatrix_1_arg.A));

        printf("Enter Second Matrix.\n");
        inputMatrix(&(addtwomatrix_1_arg.B));

        result_1 = addtwomatrix_1(&addtwomatrix_1_arg, clnt);
        if (result_1 == (Matrix *) NULL) {
            clnt_perror (clnt, "call failed");
        }
        
        printf("Output:\n");
        for(int i = 0, k = 0; i < result_1->nRows; i++) {
            for(int j = 0; j < result_1->nColumns; j++, k++) {
                printf("%5.2lf ", result_1->data[k]);
            }
            puts("");
        }

#ifndef	DEBUG
    clnt_destroy (clnt);
#endif	 /* DEBUG */
    } else if(op == 2) {

        printf("Enter First Matrix.\n");
        inputMatrix(&(multiplytwomatrix_1_arg.A));

        printf("Enter Second Matrix.\n");
        inputMatrix(&(multiplytwomatrix_1_arg.B));

        result_2 = multiplytwomatrix_1(&multiplytwomatrix_1_arg, clnt);
        if (result_2 == (Matrix *) NULL) {
            clnt_perror (clnt, "call failed");
        }
        
        printf("Output:\n");
        for(int i = 0, k = 0; i < result_2->nRows; i++) {
            for(int j = 0; j < result_2->nColumns; j++, k++) {
                printf("%5.2lf ", result_2->data[k]);
            }
            puts("");
        }

#ifndef	DEBUG
    clnt_destroy (clnt);
#endif	 /* DEBUG */
    } else if(op == 3) {

        printf("Enter Matrix.\n");
        inputMatrix(&(inversematrix_1_arg.A));
        result_3 = inversematrix_1(&inversematrix_1_arg, clnt);
        if (result_3 == (Matrix *) NULL) {
            clnt_perror (clnt, "call failed");
        }
        printf("Output:\n");
        for(int i = 0, k = 0; i < result_3->nRows; i++) {
            for(int j = 0; j < result_3->nColumns; j++, k++) {
                printf("%5.2lf ", result_3->data[k]);
            }
            puts("");
        }

#ifndef	DEBUG
    clnt_destroy (clnt);
#endif	 /* DEBUG */
    } else if(op == 4) {

        printf("Enter Matrix.\n");
        inputMatrix(&(transposematrix_1_arg.A));

        result_4 = transposematrix_1(&transposematrix_1_arg, clnt);

        if (result_4 == (Matrix *) NULL) {
            clnt_perror (clnt, "call failed");
        }
        printf("Output:\n");
        for(int i = 0, k = 0; i < result_4->nRows; i++) {
            for(int j = 0; j < result_4->nColumns; j++, k++) {
                printf("%5.2lf ", result_4->data[k]);
            }
            puts("");
        }

        if (result_4 == (Matrix *) NULL) {
            clnt_perror (clnt, "call failed");
        }
#ifndef	DEBUG
    clnt_destroy (clnt);
#endif	 /* DEBUG */
    }

}


int
main (int argc, char *argv[])
{
	char *host;

	if (argc < 2) {
		host = "localhost";
		// printf ("usage: %s server_host\n", argv[0]);
		// exit (1);
	} else{
		host = argv[1];
	}

	while(1) {
        puts("");
        puts("");
        puts("");
        printf("Enter choice :\n");
        printf("[1] Addition\n");
        printf("[2] Multiplication\n");
        printf("[3] Inverse\n");
        printf("[4] Transpose\n");
        printf("[5] Exit\n");

        int x;
        scanf("%d", &x);

        if(x >= 1 && x <= 4) {
            matrix_prog_1 (host, x);
        } else if(x == 5) {
            break;
        } else {
            printf("Enter a valid choice.\n");
        }
    }

	// matrix_prog_1 (host);
exit (0);
}


// SERVER

/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "matrixOperator.h"

Matrix *
addtwomatrix_1_svc(Massage *argp, struct svc_req *rqstp)
{
	static Matrix  result;

	puts("Add function called.");
	
	Matrix A = argp->A;
    Matrix B = argp->B;

    if(A.nRows != B.nRows || A.nColumns != B.nColumns) {
        puts("Dimension did not match. Could not perform the operation.\n");
        return &result;
    }

    result.nRows = A.nRows;
    result.nColumns = A.nColumns;

    for(int i = 0, k = 0; i < A.nRows; i++) {
        for(int j = 0; j < A.nColumns; j++, k++) {
            result.data[k] = A.data[k] + B.data[k];
        }
    }

	return &result;
}

Matrix *
multiplytwomatrix_1_svc(Massage *argp, struct svc_req *rqstp)
{
	static Matrix  result;
	
	puts("Multiplication function called.");

    Matrix A = argp->A;
    Matrix B = argp->B;

    if(A.nColumns != B.nRows) {
        puts("Dimension did not match. Could not perform the operation.\n");
        return &result;
    }

    result.nRows = A.nRows;
    result.nColumns = B.nColumns;

    for(int i = 0; i < A.nRows; i++) {
        for(int j = 0; j < B.nColumns; j++) {
            result.data[i * B.nColumns + j] = 0;
            for(int k = 0; k < A.nColumns; k++) {
                result.data[i * B.nColumns + j] += (A.data[i * A.nColumns + k] * B.data[k * B.nColumns + j]);
            }
        }
    }

	return &result;
}

Matrix *
inversematrix_1_svc(Massage *argp, struct svc_req *rqstp)
{
	static Matrix  result;

	/*
	 * insert server code here
	 */

	return &result;
}

Matrix *
transposematrix_1_svc(Massage *argp, struct svc_req *rqstp)
{
	static Matrix  result;

	/*
	 * insert server code here
	 */

	return &result;
}

